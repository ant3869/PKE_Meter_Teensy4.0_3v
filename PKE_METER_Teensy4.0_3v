/*
PKE Meter with Teensy 4.0 and DFRobot Sensors
This project integrates multiple sensors (H2S, CO, VOC, CH4) with visual and audio feedback using LEDs, a servo, and a DFPlayer Mini.

Pin Definitions:
SERVO_PIN: Pin A7
SOUND_POT_PIN: Pin A1
VOLUME_POT_PIN: Pin A2
DFPlayer Mini: RX (Pin 7), TX (Pin 8)
LED_PINS: Pins 0-6

H2S_SENSOR_PIN: Pin A3
CO_SENSOR_PIN: Pin A4
VOC_SENSOR_PIN: Pin A5
CH4_SENSOR_PIN: Pin A6

Screen (Adafruit ST7789):
#define TFT_CS 10    // Chip Select
#define TFT_DC 9     // Data/Command
#define TFT_RST 8    // Reset
#define TFT_SCK 13   // Serial Clock (hardware SPI)
#define TFT_MOSI 11  // Serial Data Out (hardware SPI)

The sketch reads sensor values, updates a display, controls LEDs, and manages sound output based on sensor data.
It includes a debug mode for easier troubleshooting and monitoring.
*/

#include <Wire.h>
#include <Servo.h>
#include <Ramp.h>
#include <TimerOne.h>
#include <DFRobotDFPlayerMini.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include <SPI.h>

#define DEBUG_MODE

#ifdef DEBUG_MODE
#define DEBUG_PRINTLN(x, d) \
  { \
    Serial.println(x); \
    delay(d); \
  }
#else
#define DEBUG_PRINTLN(x, d)
#endif

// #define USE_TEST_DATA

// ----------------------------------------------------------------------[ DEFINITIONS ]

#define CALIBRATION_TIME 13000

#define NUM_POT_SAMPLES 5
#define NUM_SENSORS 4
#define NUM_SAMPLES 5 
#define MOVING_AVERAGE_SIZE 5
#define DFPLAYER_INIT_RETRIES 5

#define NUM_LEDS 7
#define LED_SLOW 1000
#define LED_FAST 30
#define LED_ON_DELAY 1000
#define LED_OFF_DELAY 1000

#define SERVO_MIN_POS 0
#define SERVO_MAX_POS 100
#define SERVO_MIN_PULSE (SERVO_MIN_POS + 750)
#define SERVO_MAX_PULSE (SERVO_MAX_POS + 1700)

#define GRAPH_WIDTH 135
#define GRAPH_HEIGHT 160
#define GRAPH_X_OFFSET 10
#define GRAPH_Y_OFFSET 50

#define SENSOR_MIN 0
#define SENSOR_MAX 1023
#define SENSOR_THRESHOLD_LOW 466
#define SENSOR_THRESHOLD_MEDIUM 933

#define VOC_LOW 0.3
#define VOC_HIGH 0.5
#define CH4_SAFE 1000
#define H2S_SAFE 20
#define CO_SAFE_8H 9
#define CO_SAFE_1H 25

// ----------------------------------------------------------------------[ PINS ]

// Display pins
#define TFT_CS 10    // Chip Select
#define TFT_DC 9     // Data/Command
#define TFT_RST 8    // Reset
#define TFT_SCK 13   // Serial Clock (hardware SPI)
#define TFT_MOSI 11  // Serial Data Out (hardware SPI)

// Audio pins
#define SOUND_POT_PIN A1
#define VOLUME_POT_PIN A2

// Sensor pins
#define H2S_SENSOR_PIN A3
#define CO_SENSOR_PIN A4
#define VOC_SENSOR_PIN A5
#define CH4_SENSOR_PIN A6

// Servo pin
#define SERVO_PIN A7

// ----------------------------------------------------------------------[ VARIABLES ]

Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);
DFRobotDFPlayerMini myDFPlayer;
rampUnsignedInt wingRamp;
Servo myServo;

constexpr uint8_t LED_PINS[] = { 0, 1, 2, 3, 4, 5, 6 };
unsigned long ledInterval = (CALIBRATION_TIME / NUM_LEDS);
uint8_t currentLED = 0;

bool dfPlayerInitialized = false;
bool sensorsInitialized = false;

unsigned long lastReadTime = 0;
unsigned long readInterval = 500;
float processedValue = 0.0;
uint8_t lastRangeIndex = 0;

uint16_t sensorValues[NUM_SENSORS];
uint16_t sensorHistory[NUM_SENSORS][NUM_SAMPLES] = { 0 };
uint8_t sensorHistoryIndex[NUM_SENSORS] = { 0 };

uint8_t current_volume = 0;
float prev_target_pos = 0.0;
float prev_target = 0.0;

const float H2S_CONVERSION_FACTOR = 0.02;
const float CO_CONVERSION_FACTOR = 0.04;
const float VOC_CONVERSION_FACTOR = 0.01;
const float CH4_CONVERSION_FACTOR = 0.1;

// ----------------------------------------------------------------------[ FUNCTIONS ]

void playCalibrationSFX();
void playBeepSFX();
void moveServoToPosition(unsigned long elapsed);
bool shouldLightLED(unsigned long elapsed);
void lightCurrentLED(uint8_t ledIndex);
void initializeScreen();
void initializeLeds();
void controlLedsDynamic(uint16_t reading);
void initializeDFPlayer();
void setVolume(uint8_t volume);
void playTrack(uint8_t trackToPlay);
void soundControl(uint16_t value);
void initializeServo();
void parkServo();
void moveWings(uint16_t val);
void updateWings(uint16_t moveval);
void lightAllLEDs();
void nixAllLEDs();
uint16_t smoothPotValue();
void controlVolume();
void updateGraph();
void drawLabels();
void readSensors();
void updateIndicators();
void initializeSensors();
bool checkSensor(uint8_t sensorPin);
void debugMessage(const char* message, int delayTime);
float convertToPPM(uint16_t rawValue, float conversionFactor);
float convertToMGPerM3(uint16_t rawValue, float conversionFactor);
void debugGraphUpdate(int sensorIndex, int x, int y1, int y2);

// ----------------------------------------------------------------------[ INTIALIZATION ]

void setup() {
  delay(1000);

  Serial.begin(9600);
  if (!Serial) {  debugMessage("Serial (9600) has not started.", 200); }
  else{
    debugMessage("Debug mode enabled.", 1000);
  }

  Wire.begin();
  debugMessage("I2C initialized.", 0);

  // Seed the random number generator
  randomSeed(analogRead(0));

  initializeScreen();
  initializeSensors();
  initializeLeds();
  initializeDFPlayer();
  initializeServo();

  debugMessage("Initial setup complete.", 2000);
}

// ----------------------------------------------------------------------[ MAIN LOOP ]

void loop() {
  static unsigned long lastUpdateTime = 0;
  unsigned long currentTime = millis();
  controlVolume();

  if (currentTime - lastUpdateTime >= 30) {
    if (sensorsInitialized) {
      readSensors();
      updateIndicators();
      updateGraph();
    } else {
      debugMessage("Sensors not initialized. Skipping sensor read and update.", 500);
    }
    lastUpdateTime = currentTime;
  }
}

// ----------------------------------------------------------------------[ LEDS ]

void initializeLeds() {
  for (uint8_t i = 0; i < NUM_LEDS; i++) {
    pinMode(LED_PINS[i], OUTPUT);
    digitalWrite(LED_PINS[i], LOW);
  }
}

void setAllLEDs(bool state, unsigned long delayTime = 0) {
  for (uint8_t i = 0; i < NUM_LEDS; i++) {
    digitalWrite(LED_PINS[i], state ? HIGH : LOW);
  }
  delay(delayTime);
}

void lightAllLEDs() {
  setAllLEDs(true, LED_ON_DELAY);
}

void nixAllLEDs() {
  setAllLEDs(false, LED_OFF_DELAY);
}

bool shouldLightLED(unsigned long elapsed) {
  if (elapsed > currentLED * ledInterval && currentLED < NUM_LEDS) {
    currentLED++;
    return true;
  }
  return false;
}

void lightCurrentLED(uint8_t ledIndex) {
  digitalWrite(LED_PINS[ledIndex], HIGH);
}

void controlLedsDynamic(uint16_t reading) {
  uint16_t ledSpeed = map(reading, SENSOR_MIN, SENSOR_MAX, LED_SLOW, LED_FAST);
  uint16_t interval = constrain(ledSpeed, LED_FAST, LED_SLOW);

  static uint32_t previousMillis = 0;
  unsigned long currentMillis = millis();
  static uint8_t currentLed = 0;

  if (currentMillis - previousMillis >= interval) {
    digitalWrite(LED_PINS[currentLed], LOW);
    currentLed = (currentLed + 1) % NUM_LEDS;
    digitalWrite(LED_PINS[currentLed], HIGH);
    previousMillis = millis();
  }
}

// ----------------------------------------------------------------------[ AUDIO ]

void initializeDFPlayer() {
  Serial1.begin(9600);

  if (!Serial1) {
    debugMessage("Serial1 failed to start. Check connections.", 1000);
    return;
  }

  for (uint8_t attempts = 0; attempts < DFPLAYER_INIT_RETRIES; attempts++) {
    if (myDFPlayer.begin(Serial1)) {
      dfPlayerInitialized = true;
      debugMessage("DFPlayer initialized successfully.", 200);
      playBeepSFX();
      return;
    } else {
      debugMessage("DFPlayer initialization failed. Retrying...", 100);
    }
  }

  if (!dfPlayerInitialized) {
    debugMessage("DFPlayer initialization failed after multiple attempts. Check connections.", 200);
  }
}

void playBeepSFX() {
  setVolume(50);

  if (dfPlayerInitialized) {
    myDFPlayer.playFolder(1, 1);
    delay(500);
  }
}

void setVolume(uint8_t volume) {
  if (dfPlayerInitialized) {
#ifdef DEBUG_MODE
    volume = 10;
#endif

    myDFPlayer.volume(volume);
    current_volume = volume;
    delay(100);
  }
}

uint16_t smoothPotValue() {
  long total = 0;

  for (uint8_t i = 0; i < NUM_POT_SAMPLES; i++) {
    total += analogRead(SOUND_POT_PIN);
    delay(2);
  }

  return total / NUM_POT_SAMPLES;
}

void controlVolume() {
  uint16_t potValue = smoothPotValue();
  uint8_t volume = map(potValue, 0, 1023, 0, 100);

  if (volume != current_volume && dfPlayerInitialized) {
    debugMessage("Volume level: ", 0);
    debugMessage(String(volume).c_str(), 0);

    myDFPlayer.volume(volume);
    current_volume = volume;
    delay(100);
  }
}

void playTrack(uint8_t trackToPlay) {
  static uint8_t trackPlaying = -1;

  if (trackPlaying != trackToPlay) {
    myDFPlayer.stop();
    myDFPlayer.playFolder(2, trackToPlay);
    trackPlaying = trackToPlay;
  }
}

void soundControl(uint16_t value) {
  uint8_t currentRangeIndex = getSensorRangeIndex(value);

  if (currentRangeIndex != lastRangeIndex && dfPlayerInitialized) {
    playTrack(currentRangeIndex);
    lastRangeIndex = currentRangeIndex;
  }
}

// ----------------------------------------------------------------------[ SERVO ]

// Initialize the servo
void initializeServo() {
  pinMode(SERVO_PIN, OUTPUT);

#ifdef USE_PWM_SERVO
  Timer1.initialize(20000);
  Timer1.pwm(SERVO_PIN, map(90, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE));
#else
  myServo.attach(SERVO_PIN);
#endif

  delay(500);
  parkServo();
  debugMessage("Servo initialization complete.", 0);
  delay(500);
}

// Move the servo to a position based on elapsed time
void moveServoToPosition(unsigned long elapsed) {
  uint16_t position = getPositionFromElapsed(elapsed);
  moveWings(position);
}

// Park the servo at its initial position
void parkServo() {
  debugMessage("Moving servo to parked position.", 10);

  uint16_t position = getPositionFromValue(SERVO_MIN_POS);
  moveWings(position);

  debugMessage("Finished parking servo.", 0);
}

uint16_t getPositionFromElapsed(unsigned long elapsed) {
#ifdef USE_PWM_SERVO
  return map(elapsed, 0, CALIBRATION_TIME, SERVO_MIN_PULSE, SERVO_MAX_PULSE);
#else
  return map(elapsed, 0, CALIBRATION_TIME, SERVO_MIN_POS, SERVO_MAX_POS);
#endif
}

uint16_t getPositionFromValue(uint16_t value) {
#ifdef USE_PWM_SERVO
  uint16_t mappedPos = static_cast<uint16_t>(map(value, SENSOR_MIN, SENSOR_MAX, SERVO_MIN_PULSE, SERVO_MAX_PULSE));
  return constrain(mappedPos, SERVO_MIN_PULSE, SERVO_MAX_PULSE);
#else
  uint16_t mappedPos = static_cast<uint16_t>(map(value, SENSOR_MIN, SENSOR_MAX, SERVO_MIN_POS, SERVO_MAX_POS));
  return constrain(mappedPos, SERVO_MIN_POS, SERVO_MAX_POS);
#endif
}

void updateServoPosition() {
#ifdef USE_PWM_SERVO
  Timer1.setPwmDuty(SERVO_PIN, wingRamp.update());
#else
  myServo.write(wingRamp.update());
#endif
}

// Update wing position based on target value
void updateWings(uint16_t target) {
  if (target != prev_target) {
    moveWings(getPositionFromValue(target));
    prev_target = target;
  }
}

// Move the wings to a specified position
void moveWings(uint16_t target) {
  if (!wingRamp.isRunning()) {
    wingRamp.go(target, 1000, LINEAR, ONCEFORWARD);
  } else {
    updateServoPosition();
  }
}

// ----------------------------------------------------------------------[ DISPLAY ]

// Initialize display
void initializeScreen() {
  debugMessage("Initializing display ...", 500);

  tft.init(135, 240, SPI_MODE0);
  delay(100);
  tft.setRotation(3);
  tft.fillScreen(ST77XX_BLUE);
  delay(1000);
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(0, 0);
  delay(100);

  drawLabels();
}

void updateGraph() {
  static int x = GRAPH_X_OFFSET;
  static float previousSensorValues[NUM_SENSORS] = {0};

  // Clear the previous graph area only where lines are drawn
  tft.fillRect(GRAPH_X_OFFSET, GRAPH_Y_OFFSET, GRAPH_WIDTH, GRAPH_HEIGHT, ST77XX_BLACK);

  // Draw threshold lines
  tft.drawLine(GRAPH_X_OFFSET, mapSensorValueToGraph(VOC_HIGH * 100), GRAPH_X_OFFSET + GRAPH_WIDTH, mapSensorValueToGraph(VOC_HIGH * 100), ST77XX_YELLOW);
  tft.drawLine(GRAPH_X_OFFSET, mapSensorValueToGraph(CH4_SAFE), GRAPH_X_OFFSET + GRAPH_WIDTH, mapSensorValueToGraph(CH4_SAFE), ST77XX_RED);
  tft.drawLine(GRAPH_X_OFFSET, mapSensorValueToGraph(H2S_SAFE), GRAPH_X_OFFSET + GRAPH_WIDTH, mapSensorValueToGraph(H2S_SAFE), ST77XX_GREEN);
  tft.drawLine(GRAPH_X_OFFSET, mapSensorValueToGraph(CO_SAFE_1H), GRAPH_X_OFFSET + GRAPH_WIDTH, mapSensorValueToGraph(CO_SAFE_1H), ST77XX_BLUE);

  // Draw new graph lines
  for (int i = 0; i < NUM_SENSORS; i++) {
    int y1 = mapSensorValueToGraph(previousSensorValues[i]);
    int y2 = mapSensorValueToGraph(sensorValues[i]);

    // Erase the previous line by drawing over it with the background color
    tft.drawLine(x, y1, x + 1, y1, ST77XX_BLACK);

    // Draw the new line
    tft.drawLine(x, y1, x + 1, y2, getColorFromIndex(i));

    // Debug graph update
    debugGraphUpdate(i, x, y1, y2);

    // Update previous values for next iteration
    previousSensorValues[i] = sensorValues[i];
  }

  x++;
  if (x >= GRAPH_X_OFFSET + GRAPH_WIDTH) {
    x = GRAPH_X_OFFSET;
    tft.fillRect(GRAPH_X_OFFSET, GRAPH_Y_OFFSET, GRAPH_WIDTH, GRAPH_HEIGHT, ST77XX_BLACK); // Clear the graph area
  }

  // Display sensor values on the screen
  displaySensorValues(convertToPPM(sensorValues[0], H2S_CONVERSION_FACTOR), convertToPPM(sensorValues[1], CO_CONVERSION_FACTOR), convertToMGPerM3(sensorValues[2], VOC_CONVERSION_FACTOR), convertToPPM(sensorValues[3], CH4_CONVERSION_FACTOR));
}

// Function to display sensor values at the top of the screen
void displaySensorValues(float h2s, float co, float voc, float ch4) {
  tft.fillRect(0, 0, 240, 50, ST77XX_BLACK); // Clear previous values

  // Set the text color and display each sensor value
  tft.setCursor(10, 5);
  tft.setTextColor(ST77XX_RED);
  tft.setTextSize(1);
  tft.print("H2S: "); tft.print(h2s); tft.print(" ppm");

  tft.setCursor(10, 15);
  tft.setTextColor(ST77XX_GREEN);
  tft.print("CO: "); tft.print(co); tft.print(" ppm");

  tft.setCursor(10, 25);
  tft.setTextColor(ST77XX_BLUE);
  tft.print("VOC: "); tft.print(voc); tft.print(" mg/m3");

  tft.setCursor(10, 35);
  tft.setTextColor(ST77XX_YELLOW);
  tft.print("CH4: "); tft.print(ch4); tft.print(" ppm");
}

// Draw labels for the graph
void drawLabels() {
  const char* labels[] = {"H2S", "CO", "VOC", "CH4"};
  const uint16_t colors[] = {ST77XX_RED, ST77XX_GREEN, ST77XX_BLUE, ST77XX_YELLOW};

  tft.fillRect(0, 0, 240, 50, ST77XX_BLACK); // Clear the area where labels are displayed

  for (int i = 0; i < 4; i++) {
    tft.setCursor(10 + (i * 50), 5); // Position labels horizontally
    tft.setTextColor(colors[i]);
    tft.setTextSize(1);
    tft.print(labels[i]);
  }
}

uint16_t getColorFromIndex(int index) {
  switch(index) {
    case 0: return ST77XX_RED;
    case 1: return ST77XX_GREEN;
    case 2: return ST77XX_BLUE;
    default: return ST77XX_YELLOW;
  }
}

// ----------------------------------------------------------------------[ SENSORS ]

void initializeSensors() {
  debugMessage("Initializing sensors ...", 500);

  bool allSensorsInitialized = true;

  allSensorsInitialized &= checkSensor(H2S_SENSOR_PIN);
  allSensorsInitialized &= checkSensor(CO_SENSOR_PIN);
  allSensorsInitialized &= checkSensor(VOC_SENSOR_PIN);
  allSensorsInitialized &= checkSensor(CH4_SENSOR_PIN);

  if (allSensorsInitialized) {
    sensorsInitialized = true;
    debugMessage("All sensors initialized successfully.", 1000);
  } else {
    sensorsInitialized = false;
    debugMessage("One or more sensors failed to initialize.", 1000);
  }
}

uint16_t movingAverage(uint16_t* values, uint8_t size) {
  uint32_t sum = 0;
  for (uint8_t i = 0; i < size; i++) {
    sum += values[i];
  }
  return sum / size;
}

void generateTestData(uint16_t &h2s, uint16_t &co, uint16_t &voc, uint16_t &ch4) {
  h2s = random(SENSOR_MIN, SENSOR_MAX + 1);
  co = random(SENSOR_MIN, SENSOR_MAX + 1);
  voc = random(SENSOR_MIN, SENSOR_MAX + 1);
  ch4 = random(SENSOR_MIN, SENSOR_MAX + 1);
}

void readTestData(uint16_t *sensorValues) {
  generateTestData(sensorValues[0], sensorValues[1], sensorValues[2], sensorValues[3]);
}

bool useTestData() {
#ifdef USE_TEST_DATA
  return true;
#else
  return false;
#endif
}

bool checkSensor(uint8_t sensorPin) {
  int sensorValue = analogRead(sensorPin);
  if (sensorValue >= SENSOR_MIN && sensorValue <= SENSOR_MAX) {
    debugMessage(("Sensor initialized successfully: " + String(sensorPin)).c_str(), 500);
    return true;
  } else {
    debugMessage(("Sensor initialization failed: " + String(sensorPin)).c_str(), 500);
    return false;
  }
}

void readSensor(uint8_t sensorPin, uint16_t &sensorValue, uint16_t *sensorHistory, uint8_t &historyIndex) {
  uint16_t currentValue = analogRead(sensorPin);
  sensorHistory[historyIndex] = currentValue;
  historyIndex = (historyIndex + 1) % NUM_SAMPLES;

  uint32_t sum = 0;
  for (uint8_t i = 0; i < NUM_SAMPLES; i++) {
    sum += sensorHistory[i];
  }
  sensorValue = sum / NUM_SAMPLES;
}

void readSensors() {
  if (useTestData()) {
    // Use test data instead of actual sensor readings
    readTestData(sensorValues);
  } else {
    // Original sensor reading logic
    readSensor(H2S_SENSOR_PIN, sensorValues[0], sensorHistory[0], sensorHistoryIndex[0]);
    readSensor(CO_SENSOR_PIN, sensorValues[1], sensorHistory[1], sensorHistoryIndex[1]);
    readSensor(VOC_SENSOR_PIN, sensorValues[2], sensorHistory[2], sensorHistoryIndex[2]);
    readSensor(CH4_SENSOR_PIN, sensorValues[3], sensorHistory[3], sensorHistoryIndex[3]);
  }

  // Update the sensor history and apply moving average
  for (int i = 0; i < NUM_SENSORS; i++) {
    sensorHistory[i][sensorHistoryIndex[i]] = sensorValues[i];
    sensorHistoryIndex[i] = (sensorHistoryIndex[i] + 1) % MOVING_AVERAGE_SIZE;
    sensorValues[i] = movingAverage(sensorHistory[i], MOVING_AVERAGE_SIZE);
  }

  // Convert and display sensor values in ppm or mg/m3
  float h2s_ppm = convertToPPM(sensorValues[0], H2S_CONVERSION_FACTOR);
  float co_ppm = convertToPPM(sensorValues[1], CO_CONVERSION_FACTOR);
  float voc_mg_m3 = convertToMGPerM3(sensorValues[2], VOC_CONVERSION_FACTOR);
  float ch4_ppm = convertToPPM(sensorValues[3], CH4_CONVERSION_FACTOR);

  debugMessage(("H2S: " + String(h2s_ppm) + " ppm, ").c_str(), 0);
  debugMessage(("CO: " + String(co_ppm) + " ppm, ").c_str(), 0);
  debugMessage(("VOC: " + String(voc_mg_m3) + " mg/mÂ³, ").c_str(), 0);
  debugMessage(("CH4: " + String(ch4_ppm) + " ppm").c_str(), 500);

  // Print raw sensor values for debugging
  Serial.print("Raw Sensor Values - H2S: ");
  Serial.print(sensorValues[0]);
  Serial.print(", CO: ");
  Serial.print(sensorValues[1]);
  Serial.print(", VOC: ");
  Serial.print(sensorValues[2]);
  Serial.print(", CH4: ");
  Serial.println(sensorValues[3]);
}

uint16_t getMaxSensorReading() {
  uint16_t maxReading = 0;
  for (uint8_t i = 0; i < NUM_SENSORS; i++) {
    if (sensorValues[i] > maxReading) {
      maxReading = sensorValues[i];
    }
  }
  return maxReading;
}

uint8_t getSensorRangeIndex(uint16_t value) {
  if (value <= SENSOR_THRESHOLD_LOW)
    return 1;
  else if (value <= SENSOR_THRESHOLD_MEDIUM)
    return 2;
  else
    return 3;
}

float convertToPPM(uint16_t rawValue, float conversionFactor) {
  return rawValue * conversionFactor;
}

float convertToMGPerM3(uint16_t rawValue, float conversionFactor) {
  return rawValue * conversionFactor;
}

// ----------------------------------------------------------------------[ HELPER FUNCTION ]

// Debug message (if) debug mode active
void debugMessage(const char* message, int delayTime) {
  #ifdef DEBUG_MODE
    Serial.println(message);
    delay(delayTime);
  #endif
}

// Update indicators based on sensor readings
void updateIndicators() {
  uint16_t maxReading = getMaxSensorReading();

  controlLedsDynamic(maxReading);
  soundControl(maxReading);
  updateWings(maxReading);

  debugMessage(("Highest value: " + String(maxReading)).c_str(), 10);
}

void debugGraphUpdate(int sensorIndex, int x, int y1, int y2) {
  Serial.print("Sensor ");
  Serial.print(sensorIndex);
  Serial.print(": Drawing line from (");
  Serial.print(x);
  Serial.print(", ");
  Serial.print(y1);
  Serial.print(") to (");
  Serial.print(x + 1);
  Serial.print(", ");
  Serial.print(y2);
  Serial.println(")");
}

int mapSensorValueToGraph(int sensorValue) {
  return GRAPH_Y_OFFSET + GRAPH_HEIGHT - map(sensorValue, SENSOR_MIN, SENSOR_MAX, 0, GRAPH_HEIGHT);
}
